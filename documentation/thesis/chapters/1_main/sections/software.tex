%
\lstset{
	basicstyle=\scriptsize,
	language=C++,
	breaklines=true,
	%		frameround=fttt,
	frame=tbrl,
	breakatwhitespace=false
	breaklines=true,  
	xleftmargin=1cm,
	tabsize=2,
	showstringspaces=false}
%---------------------------------------------------------------------
%
\subsection{Shark}
\label{sec:Shark}
Shark ist eine Open-Source \cpp Library für Maschinelles Lernen und Optimierung ~\cite{Shark:1}. Es Implementiert Methoden für lineare und nicht lineare Optimierung, Kernel-basierte Lernverfahren, künstliche neuronale Netzwerke, und Weitere. Details der Umsetzung finden sich in~\cite{shark08}. Es wird sowohl in Forschung als auch industriellem Umfeld eingesetzt und implementiert, nach eigenen Angaben, Algorithmen die in anderen Libraries nicht verfügbar sind. Shark baut auf den \textit{Boost C++ Libraries} auf und verwendet CMake\footnote{CMake (cross-platform make) ist ein plattformunabhängiges Programmierwerkzeug für die Entwicklung und Erstellung von Software.}. Dadurch ist es nahezu auf jeder Plattform verfügbar. Die Integration in ein Projekt ist sehr einfach und daher wird es in dieser Arbeit eingesetzt.\\

Eine Integration von Shark in dem Software Ökosystem ist aufgrund der vielen Features sehr sinnvoll. Weitere Entwicklungen können vom Funktionsumfang partizipieren.

%
%---------------------------------------------------------------------
\subsection{Implementation}
\label{sec:Implementation}
In diesem Abschnitt wird auf interessante Details der Softwareimplementation eingegangen. Es ist nicht möglich im vollen Umfang die Implementation der Softare besprechen, dafür ist die Software zu Umfangreich\footnote{Für diese Arbeit wurden ca. $5000$ Zeilen Quellcode erstellt - einzelne Modelle nicht mitgerechnet}. Lediglich sollen hier die Implementationen verschiedener Evolutionsalgorithmen unter Verwendung von Shark gezeigt werden. Verschiedene Algorithmen wurden in Kapitel~\ref{sec:es-common} Es wird beispielhaft die Implementation einer Objektfunktion beschrieben, wie sie typischerweise in Shark vorgenommen wird.
%
%\input{diagrams/prpsevolution-integration.tex}
%
%---------------------------------------------------------------------
\subsubsection{Objektfunktion in Shark}
\label{sec:Shark_model}
%
Als Beispiel für die Implementation einer Objektfunktion wird im Folgenden das Modell der evolutionären Kalibrierung besprochen. Dieses Modell, bzw. Objektfunktion, hat eine überschaubare Komplexität und wurde bereits im Abschnitt~\ref{sec:calibration} zur Veranschaulichung verwendet. Daher eignet es sich gut um die Implementation zu zeigen. Im Rahmen dieser Arbeit sind eine Vielzahl von Modellen entstanden, die nicht in aller Ausführlichkeit diskutiert werden können.\\
%
%---------------------------------------------------------------------
Das Listing~\ref{lst:EvolutionaryCalibration.h} zeigt die Headerdatei für die Implementation einer Objektfunktion, sofort ist zu erkennen, das sie von der abstakten Klasse \textit{SingleObjectiveFunction} abgeleitet ist. Diese ist einer von Shark bereitgestellte Klasse. Sie beschreibt die Funktionen die eine Objektfunktion implementieren muss damit sie von Optimizern verwendet werden kann. Ein von dieser Klasse abgeleitetes Modell erlaubt die Verwendung in verschiedenen Algorithmen. Die Funktion:
%
\begin{lstlisting}
double eval(const SearchPointType &p) const;
\end{lstlisting}
%
wird in von den Optimizern aufgerufen und implementiert die eigentliche Funktion des Modells.
%
\begin{lstlisting}[label=EvolutionaryCalibration_2]
void proposeStartingPoint(SearchPointType &x) const;
\end{lstlisting}
%
Diese Methode wird von einem Solver beim Start aufgerufen und liefert passende Startwerte für das Modell zurück. Der Rückgabewert der Funktion ist ein gleichverteilter Vektor der Dimension \textit{m\_numberOfVariables} in einem Intervall von $[-10,10]$ zurück. Der Wert für \textit{m\_numberOfVariables} wird bei der Instanziierung des Modells, beim Aufruf des Konstruktors, gesetzt. Dort wird auch die Eigenschaft \textit{CAN\_PROPOSE\_STARTING\_POINT} gesetzt, sie wird von den unterschiedlichen Optimizern verwendet um zu erkennen, welche Features vom Modell unterstützt werden.
%
\begin{lstlisting}[label=EvolutionaryCalibration_3]
	EvolutionaryCalibration( ) {
	m_numberOfVariables = Solve::ProblemDimensions::Calibration;
	m_features |= CAN_PROPOSE_STARTING_POINT;
}
\end{lstlisting}	
%
%---------------------------------------------------------------------
%
\lstinputlisting[caption=Quellcode Schnipsel für die Deklaration einer Objektfunktion \vspace{2mm},
				firstline=18, lastline=108, label=lst:EvolutionaryCalibration.h]{src/EvolutionaryCalibration.h}
%
Die in Listig~\ref{lst:EvolutionaryCalibration.cpp} gezeigte cpp-Datei ist die Implementation der oben beschriebenen Modellfunktionen. Aus diesen beiden Dateien ist ersichtlich, dass die Deklaration des Modells sehr überschaubar ist. Praktische jedes Modell hat diese übersichtliche Struktur, das erhöht die Wartbarkeit enorm. Außerdem erlaubt es einen einfachen Austausch in der Implementation sowie die Verwendung in unterschiedlichen Algorithmen. 
%
\begin{lstlisting}[label=EvolutionaryCalibration_4]
inline double EvolutionaryCalibration::mkII( const NRmatrix<Doub> &A, const double* x, const NRvector<Doub> &b ) const
\end{lstlisting}
%
Diese Funktion ist die eigentliche Berechnung des Gleichungssystems der Form $\mathbf{A}\mathbf{x}=\textbf{b}$. Die Lösung wird an die Aufrufende Funktion übergeben. Als Eingabe wird der Variablenvektor \textit{const double*x} von Shark sowie die geom. Matrix $\mathbf{A}$ und der Distanzvektor $\mathbf{b}$ erwartet.
%
Der vollständige Quellcode des Modells ist im Anhang~\ref{app:EvolutionaryCalibration1} und \ref{app:EvolutionaryCalibration2} gelistet.
%
%---------------------------------------------------------------------
%
\lstinputlisting[caption=Quellcode Schnipsel für die Implementation einer Objektfunktion für verschiedene Optimzier im Shark\vspace{2mm},
				 firstline=7, lastline=44, label=lst:EvolutionaryCalibration.cpp]{src/EvolutionaryCalibration.cpp}
%
%
\subsection{Process MkII - Finde die Lösung}

%
\subsection{Paralleler Ablauf}
\label{parallel_computing}
%
Die \textit{ProcessMkII}-Klasse ist Threadfähig. Eine Implementierung wurde im Rahmen der Arbeit durchgeführt. Durch das parallele Ablaufen verschiedener Optimierungen kann die Performance wesentlicher verbessert werden und so die Multi-Kern-Architektur aktueller Rechner ausgenutzt werden. Einen großen Beitrag zur schnellen Umsetzung lieferte der neue Standard \cpp11. Dieser Implementiert ein High-Level Konstrukt für Threads und Tasks, sodass es einfacher ist, Abläufe zu Synchronisieren und Ergebnisse abzufragen. Zusätzlich ist die Implementation sehr leicht, wie im folgenden Listing gezeigt:
%
\lstinputlisting[caption=Erstellen von mehreren Threads bei gleichzeitiger Übergabe der Parameter\vspace{2mm},
				 firstline=1, lastline=19]{src/async.cpp}
				 \label{lst:Parallel_example1.cpp}
%
\vspace{2mm}
Das Abfragen der Ergebnisse ist genauso einfach:
\vspace{2mm}
%
\lstinputlisting[caption=Abfragen der Asynchronen Ergebnisse mit Hilfe des auto-Datentyp. Ausgabe des Ergebnisses in einer Datei.\vspace{2mm},
				 firstline=23, lastline=36]{src/async.cpp}
				 \label{lst:Parallel_example2.cpp}
%
\vspace{2mm}
%
\subsection{Schnittstelle für Dateneingabe}
%
Im Folgenden wird die implementierte Schnittstelle besprochen mit der die Daten unter den Programmteilen ausgetauscht werden können. Die Schnittstelle umfasst im Wesentliche zwei Teile:
\begin{enumerate}
	\item Eingabe für die gemessenen Phasenwerte
	\item Ausgabe für die ermittelten Wellenzahlen
\end{enumerate}
%
Hinzukommt eine pseudo-Schnittstelle über die die Systemparameter eingelesen werden können. Die aktuelle Implementation ließt lediglich eine CSV-Eingabedatei, mit den Systemparametern in eine entsprechende Struktur ein. Diese Parameter stehen Anschließend dem PRPS-Evolution System zur Verfügung.
%
Die Kommunikation zwischen dem PRPS-Dienst und dem PRPS-Evolution ist einfach. Der Dienst teilt die gemessenen Phasendaten mit, die vom PRPS-Evolution für die Berechnung der Wellenzahlen verwendet werden. Das bedeutet das der Ablauf des Auffindens der Wellenzahl vom PRPS-Dienst als 'Black-Box' angesehen wird.\\
%
%\subsubsection{Schnittstelle für Dateneingabe}
%
\subsection{Ablaufdiagramme}
%
Vieles der Funktionalität der Software ist zu umfangreich für dieses Dokument. Es kann in diesem Rahmen keine vollständige Besprechung des Quellcodes durchgeführt werden. Wichtige Funktionalitäten und Abläufe werden in Ablaufplänen zusammenfassend dargestellt.
%
\input{chapters/1_main/sections/programm_start.tex}
%
\input{chapters/1_main/sections/find_solution.tex}
%
\input{chapters/1_main/sections/struct_model.tex}
%

%\lipsum[1-5]